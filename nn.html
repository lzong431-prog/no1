<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8">
<title>å¸ƒæ—é€šé“é¢„æµ‹ï¼ˆé˜ˆå€¼åŒºé—´æ¥è¿‘é€šçŸ¥ Â· è½»é‡ç»˜å›¾ï¼‰</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body { font-family: Arial; margin:20px; color:#222; }
h2 { margin:6px 0 10px; }
#controls { display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
#prediction { font-size:18px; margin-bottom:8px; color:#0066cc; }
input[type="text"], input[type="password"], input[type="number"] { padding:6px; border:1px solid #ccc; border-radius:4px; width:200px; }
button { padding:6px 10px; border-radius:4px; border:1px solid #bbb; background:#f7f7f7; cursor:pointer; }
button.primary { background:#0066cc; color:#fff; border-color:#0057a3; }
#latestResult { margin:8px 0 12px; padding:10px; border:1px solid #ccc; background:#fafafa; }
#last30 { display:flex; gap:6px; align-items:center; margin:10px 0; flex-wrap:nowrap; overflow-x:auto; padding:6px 0; }
.box { width:34px; height:34px; border-radius:6px; display:flex; align-items:center; justify-content:center; font-weight:700; color:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.07); }
.box.small { background: #1976d2; } /* blue for å° */
.box.big { background: #2e7d32; }   /* green for å¤§ */
.box.latest { outline: 3px solid rgba(0,0,0,0.12); }
#stats { margin:8px 0 12px; padding:8px; border:1px solid #ddd; background:#fffbe6; }
#recordPanel { margin-top:12px; max-height:340px; overflow:auto; border:1px solid #ccc; padding:10px; background:#fff; }
table { border-collapse: collapse; width:100%; }
th, td { border:1px solid #ddd; padding:6px; text-align:center; font-size:13px; }
th { background:#f0f0f0; }
.small { font-size:12px; color:#666; }
.status { font-size:13px; color:#555; margin-left:8px; }
</style>
</head>
<body>

<h2>ç¬¬ä¸€å Â· å¸ƒæ—é€šé“é¢„æµ‹ï¼ˆé˜ˆå€¼åŒºé—´æ¥è¿‘é€šçŸ¥ï¼‰</h2>

<div id="controls">
  <div>
    <label>Bot Tokenï¼š</label><br>
    <input id="botTokenInput" type="password" placeholder="123456:ABC-DEF_your_bot_token" />
  </div>
  <div>
    <label>Chat IDï¼š</label><br>
    <input id="chatIdInput" type="text" placeholder="ç›®æ ‡ chat_idï¼ˆç¾¤æˆ–ä¸ªäººï¼‰" />
  </div>

  <div>
    <label>é«˜é˜ˆå€¼ï¼ˆæ¥è¿‘40ï¼‰ï¼š</label><br>
    <input id="highThreshInput" type="number" step="1" value="38" />
  </div>
  <div>
    <label>ä½é˜ˆå€¼ï¼ˆæ¥è¿‘-10ï¼‰ï¼š</label><br>
    <input id="lowThreshInput" type="number" step="1" value="-8" />
  </div>

  <div>
    <label>é˜ˆå€¼ç¼“å†²ï¼ˆÂ±ï¼‰ï¼š</label><br>
    <input id="marginInput" type="number" step="1" value="5" />
  </div>

  <div style="display:flex;flex-direction:column;gap:6px;">
    <button id="saveCredBtn" class="primary">ä¿å­˜è®¾ç½®</button>
    <button id="testNotifyBtn">æµ‹è¯•é€šçŸ¥</button>
    <div class="status" id="credStatus"></div>
  </div>

  <div style="margin-left:auto;">
    <button onclick="exportPredictionCSV()">å¯¼å‡ºé¢„æµ‹è®°å½• CSV</button>
  </div>
</div>

<div id="prediction">ç­‰å¾…æœ€æ–°é¢„æµ‹â€¦</div>
<canvas id="chart" width="1200" height="420"></canvas>

<div id="latestResult">æœ€æ–°å¼€å¥–ï¼šåŠ è½½ä¸­â€¦</div>

<div id="last30" title="è¿‘30æœŸç¬¬ä¸€åï¼ˆå³ä¾§ä¸ºæœ€æ–°ï¼‰"></div>

<div id="stats">
  <strong>ç»Ÿè®¡</strong>ï¼š
  <span id="statTotal">æ€»é¢„æµ‹: 0</span>ã€€
  <span id="statValid">æœ‰æ•ˆ: 0</span>ã€€
  <span id="statInvalid">æ— æ•ˆ: 0</span>ã€€
  <span id="statHits">å‘½ä¸­: 0</span>ã€€
  <span id="statRate">æ€»ä½“å‘½ä¸­ç‡: 0%</span>ã€€
  <span id="statCurStreak">å½“å‰è¿æŒ‚: 0</span>ã€€
  <span id="statMaxStreak">æœ€å¤§è¿æŒ‚: 0</span>ã€€
  <span id="statLock">å½“å‰é”å®š: æ— </span>ã€€
  <span id="statOsc">æŒ¯è¡: æ— </span>
  <div class="small" id="statDetail"></div>
</div>

<div id="recordPanel">
  <h3>é¢„æµ‹è®°å½•ï¼ˆåŒ…å«æœ‰æ•ˆ/æ— æ•ˆ/é”å®š/æŒ¯è¡ï¼‰</h3>
  <table>
    <thead>
      <tr>
        <th>é¢„æµ‹æœŸå·</th>
        <th>ç±»å‹</th>
        <th>é¢„æµ‹</th>
        <th>å®é™…</th>
        <th>å‘½ä¸­</th>
        <th>é”å®šæœŸæ•°</th>
        <th>æŒ¯è¡</th>
        <th>é¢„æµ‹æ—¶é—´</th>
      </tr>
    </thead>
    <tbody id="recordBody"></tbody>
  </table>
</div>

<script>
/* ====== åŸºç¡€é…ç½® ====== */
const API = "https://api.api68.com/pks/getPksHistoryList.do?lotCode=10037";
const WINDOW = 20;
const DECAY = 0.85;
const UPDATE_INTERVAL = 1000;

/* ====== çŠ¶æ€ ====== */
let labels = [], redArr = [], midArr = [], upperArr = [], lowerArr = [];
let firstNums = [];
let predictionRecords = [];
let markLines = [];
let lastPredictedIssue = null;
let chart = null;
let activeLock = null;

/* ====== é€šçŸ¥é˜ˆå€¼ & é˜²é‡é€šçŸ¥çŠ¶æ€ ====== */
let lastNotifiedHighIssue = null;
let lastNotifiedLowIssue = null;
let lastNotifiedMissStreak = 0;
let lastNotifiedHitStreak = 0;
/* ç”¨äºâ€œä»å¤–éƒ¨è¿›å…¥åŒºé—´â€æ£€æµ‹ï¼Œé¿å…è¿ç»­å¤šæœŸé‡å¤é€šçŸ¥ */
let prevHighInRange = false;
let prevLowInRange = false;

/* ====== é»˜è®¤é˜ˆå€¼ï¼ˆå¯ç”± UI ä¿®æ”¹ï¼‰ ====== */
const DEFAULT_HIGH = 38;
const DEFAULT_LOW = -8;
const DEFAULT_MARGIN = 5;

/* ====== å·¥å…· ====== */
const mean = a => a.reduce((x,y)=>x+y,0)/a.length;
const std = a => Math.sqrt(mean(a.map(x=>(x-mean(a))**2)));

/* ====== ä¿å­˜ / åŠ è½½è®¾ç½®ï¼ˆToken/ChatID/é˜ˆå€¼/ç¼“å†²ï¼‰ ====== */
function saveSettings(){
  localStorage.setItem("tg_bot_token", document.getElementById("botTokenInput").value.trim());
  localStorage.setItem("tg_chat_id", document.getElementById("chatIdInput").value.trim());
  localStorage.setItem("notify_high_thresh", document.getElementById("highThreshInput").value.trim());
  localStorage.setItem("notify_low_thresh", document.getElementById("lowThreshInput").value.trim());
  localStorage.setItem("notify_margin", document.getElementById("marginInput").value.trim());
  updateCredStatus();
}
function loadSettings(){
  return {
    token: localStorage.getItem("tg_bot_token") || "",
    chatId: localStorage.getItem("tg_chat_id") || "",
    high: parseFloat(localStorage.getItem("notify_high_thresh") || DEFAULT_HIGH),
    low: parseFloat(localStorage.getItem("notify_low_thresh") || DEFAULT_LOW),
    margin: parseFloat(localStorage.getItem("notify_margin") || DEFAULT_MARGIN)
  };
}
function updateCredStatus(){
  const s = document.getElementById("credStatus");
  const cfg = loadSettings();
  if(cfg.token && cfg.chatId) s.innerText = `å·²ä¿å­˜ Token ä¸ Chat IDï¼›é«˜é˜ˆ=${cfg.high}ï¼Œä½é˜ˆ=${cfg.low}ï¼Œç¼“å†²Â±${cfg.margin}`;
  else s.innerText = "Token æˆ– Chat ID æœªå®Œæ•´è®¾ç½®";
}
document.getElementById("saveCredBtn").addEventListener("click", ()=>{
  saveSettings();
  alert("å·²ä¿å­˜è®¾ç½®ï¼ˆä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ storageï¼‰");
});
document.getElementById("testNotifyBtn").addEventListener("click", ()=>{
  const cfg = loadSettings();
  if(!cfg.token || !cfg.chatId){ alert("è¯·å…ˆè¾“å…¥å¹¶ä¿å­˜ Bot Token ä¸ Chat ID"); return; }
  const testRecord = { issue: "TEST", prediction: "æç¤ºæµ‹è¯•ï¼šé˜ˆå€¼åŒºé—´æ¥è¿‘", valid:true, lockedSeq:0, time: new Date().toLocaleString(), oscillation:false };
  notifyTelegramSimple(testRecord);
  alert("å·²å‘é€æµ‹è¯•é€šçŸ¥ï¼Œè‹¥æœªæ”¶åˆ°è¯·æ£€æŸ¥ token/chat_id");
});
/* åˆå§‹åŒ– UI */
const saved = loadSettings();
document.getElementById("botTokenInput").value = saved.token || "";
document.getElementById("chatIdInput").value = saved.chatId || "";
document.getElementById("highThreshInput").value = saved.high || DEFAULT_HIGH;
document.getElementById("lowThreshInput").value = saved.low || DEFAULT_LOW;
document.getElementById("marginInput").value = saved.margin || DEFAULT_MARGIN;
updateCredStatus();

/* ====== é€šçŸ¥ï¼šå‰ç«¯ç›´æ¥è°ƒç”¨ Telegramï¼ˆæœ€ç®€å•ï¼Œå­˜åœ¨æ³„éœ²é£é™©ï¼‰ ====== */
const notifyRate = { lastSentForIssue: {}, minIntervalMs: 5000 }; // per-issue rate-limit

async function notifyTelegramSimple(record){
  try{
    if(!record || !record.issue) return;
    const key = String(record.issue);
    const now = Date.now();
    const last = notifyRate.lastSentForIssue[key] || 0;
    if(now - last < notifyRate.minIntervalMs){
      console.log("é€šçŸ¥é€Ÿç‡é™åˆ¶ï¼Œè·³è¿‡é‡å¤æ¨é€", record.issue);
      return;
    }
    notifyRate.lastSentForIssue[key] = now;

    const cfg = loadSettings();
    const BOT_TOKEN = cfg.token;
    const CHAT_ID = cfg.chatId;
    if(!BOT_TOKEN || !CHAT_ID){
      console.log("é€šçŸ¥æœªå‘é€ï¼šæœªé…ç½® BOT_TOKEN æˆ– CHAT_ID");
      return;
    }

    const title = `æç¤ºï¼š${record.prediction}`;
    const parts = [
      `è¯¦æƒ…ï¼š${record.prediction}`,
      record.lockedSeq ? `é”å®šæœŸï¼š${record.lockedSeq}` : "",
      record.oscillation ? `æŒ¯è¡ï¼šæ˜¯` : "",
      `æ—¶é—´ï¼š${record.time || (new Date()).toLocaleString()}`
    ].filter(Boolean);
    const text = `${title}\n` + parts.join("  Â·  ");

    const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
    const body = { chat_id: CHAT_ID, text: text };

    fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    }).then(resp => resp.json())
      .then(j => {
        if(!j.ok) console.warn("Telegram è¿”å›é”™è¯¯ï¼š", j);
        else console.log("å·²å‘é€ Telegram é€šçŸ¥ï¼š", record.issue);
      }).catch(err => console.warn("å‘é€ Telegram å¤±è´¥ï¼š", err));
  }catch(e){
    console.warn("notifyTelegramSimple error", e);
  }
}

/* ====== å¸ƒæ—ä¸é¢„æµ‹æ ¸å¿ƒå‡½æ•°ï¼ˆä¸ä¹‹å‰é€»è¾‘ä¸€è‡´ï¼‰ ====== */
const DIST_RATIO_THRESHOLD = 0.35;
const BANDWIDTH_RATIO_THRESHOLD = 0.15;
const SLOPE_THRESHOLD = 0.5;
const LOCK_BW_THRESHOLD = 0.30;
const LOCK_MOMENTUM_DECAY_RATIO = 0.7;
const OSC_WINDOW = 8;
const OSC_THRESHOLD = 0.75;

function isValidZone(i){
  if(i<=WINDOW) return false;
  const up = upperArr[i], low = lowerArr[i], mid = midArr[i];
  if(mid === null || up === null || low === null) return false;
  const dist = Math.abs(redArr[i]-mid)/(up-low || 1e-9);
  const width = (up-low)/(Math.abs(mid) || 1e-9);
  const slope = Math.abs(redArr[i]-redArr[i-1]);
  return dist >= DIST_RATIO_THRESHOLD && width >= BANDWIDTH_RATIO_THRESHOLD && slope >= SLOPE_THRESHOLD;
}
function detectOscillation(){
  const n = firstNums.length;
  if(n < 3) return {osc:false, rate:0};
  const m = Math.min(OSC_WINDOW, n);
  const tail = firstNums.slice(n - m, n);
  let flips = 0;
  for(let i=1;i<tail.length;i++){
    const prev = tail[i-1] >= 6 ? 1 : 0;
    const cur = tail[i] >= 6 ? 1 : 0;
    if(prev !== cur) flips++;
  }
  const rate = flips / (m - 1);
  return {osc: rate >= OSC_THRESHOLD, rate};
}
function shouldTriggerLock(i){
  if(i<=WINDOW+1) return false;
  const up = upperArr[i], low = lowerArr[i], mid = midArr[i];
  if(mid === null || up === null || low === null) return false;
  const bandWidthRatio = (up - low) / (Math.abs(mid) || 1e-9);
  if(bandWidthRatio < LOCK_BW_THRESHOLD) return false;
  const slopeCurr = redArr[i] - redArr[i-1];
  const slopePrev = redArr[i-1] - redArr[i-2];
  if(slopeCurr === 0 || slopePrev === 0) return false;
  if(Math.sign(slopeCurr) === Math.sign(slopePrev) && Math.abs(slopeCurr) <= Math.abs(slopePrev) * LOCK_MOMENTUM_DECAY_RATIO){
    const dist = Math.abs(redArr[i] - mid) / ((up - low) || 1e-9);
    if(dist >= 0.20) return true;
  }
  return false;
}
function predictDirection(i){
  return (redArr[i] - redArr[i-1]) >= 0 ? "å¤§" : "å°";
}

/* ====== æ¸²æŸ“å‡½æ•° ====== */
function showLatestResult(data){
  const last = data[data.length-1];
  const first = parseInt(last.preDrawCode.split(",")[0]);
  const size = first <= 5 ? "å°" : "å¤§";
  document.getElementById("latestResult").innerHTML =
    `ğŸ¯ æœ€æ–°å¼€å¥–æœŸå·ï¼š<b>${last.preDrawIssue}</b>ã€€ç¬¬ä¸€åï¼š<b>${first}</b>ã€€ç»“æœï¼š<b>${size}</b>`;
}
function renderLast30(data){
  const container = document.getElementById("last30");
  container.innerHTML = "";
  const sliceCount = 30;
  const tail = data.slice(-sliceCount);
  tail.forEach((d, idx) => {
    const num = parseInt(d.preDrawCode.split(",")[0]);
    const isBig = num >= 6;
    const box = document.createElement("div");
    box.className = "box " + (isBig ? "big" : "small");
    if(idx === tail.length - 1) box.className += " latest";
    box.title = `æœŸ ${d.preDrawIssue}ï¼š${num} (${isBig ? 'å¤§' : 'å°'})`;
    box.innerText = num;
    container.appendChild(box);
  });
}

/* ====== ä¸»å¾ªç¯ ====== */
async function fetchData(){
  try{
    const res = await fetch(API);
    const json = await res.json();
    const data = json.result.data.reverse();

    labels = []; redArr = []; midArr = []; upperArr = []; lowerArr = []; firstNums = [];
    let raw = [], score = 0;
    data.forEach(d=>{
      const first = parseInt(d.preDrawCode.split(",")[0]);
      firstNums.push(first);
      const v = first <= 5 ? -first : first;
      score = score * DECAY + v;
      raw.push(score);
      labels.push(d.preDrawIssue);
    });

    for(let i=0;i<raw.length;i++){
      redArr.push(raw[i]);
      if(i < WINDOW){
        midArr.push(null); upperArr.push(null); lowerArr.push(null);
      } else {
        const w = raw.slice(i-WINDOW, i);
        const m = mean(w);
        const s = std(w);
        midArr.push(m);
        upperArr.push(m + 2*s);
        lowerArr.push(m - 2*s);
      }
    }

    showLatestResult(data);
    renderLast30(data);
    processPredictionWithOscLock(data);
    settleResults(data);
    checkExtraNotifications(data); // <-- åŒºé—´æ¥è¿‘é€»è¾‘åœ¨è¿™é‡Œ
    drawChart();
    renderPanel();
    updateStats();
  } catch(e){
    console.error("æ‹‰å–æ•°æ®å¤±è´¥:", e);
  }
}

/* ====== é¢„æµ‹å¤„ç†ï¼ˆéœ‡è¡é”å®š & åŸæœ‰é€»è¾‘ï¼‰ ====== */
// ï¼ˆæ­¤å¤„é€»è¾‘ä¸ä¹‹å‰ç‰ˆæœ¬ä¸€è‡´ï¼šä¸å†æ¯æœŸé€šçŸ¥ï¼‰
function processPredictionWithOscLock(data){
  if(redArr.length < 3) return;
  const latestIssue = data[data.length-1].preDrawIssue;
  if(lastPredictedIssue === latestIssue) return;
  const i = redArr.length - 2;
  if(i <= WINDOW) return;

  const oscRes = detectOscillation();
  const isOsc = oscRes.osc;
  const oscRate = oscRes.rate;

  if(activeLock && activeLock.active){
    if(activeLock.reason === 'osc'){
      if(isOsc){
        activeLock.count += 1;
        const pred = activeLock.prediction;
        const record = {
          issue: latestIssue + 1, prediction: pred, actual: "ç­‰å¾…", hit: "",
          time: new Date().toLocaleString(), valid: activeLock.validOnStart, markIndex: i,
          color: activeLock.color, lockedSeq: activeLock.count, oscillation: true, oscRate: Math.round(oscRate*1000)/10, reason: 'osc'
        };
        predictionRecords.push(record);
        markLines.push({ index: i, color: activeLock.color });
        lastPredictedIssue = latestIssue;
        document.getElementById("prediction").innerText = `æŒ¯è¡é”å®šä¸­ï¼ˆ${activeLock.count}æœŸï¼‰ï¼šé¢„æµ‹ ${record.issue} æœŸ = ${pred}`;
        return;
      } else {
        activeLock.active = false; activeLock = null;
        document.getElementById("prediction").innerText = `æŒ¯è¡è§£é™¤ï¼Œé‡æ–°è¯„ä¼° ${latestIssue+1} æœŸ`;
      }
    } else {
      const slopeCurr = redArr[i] - redArr[i-1];
      const currSign = Math.sign(slopeCurr);
      if(currSign === 0 || currSign !== activeLock.predSign){
        activeLock.active = false; activeLock = null;
        document.getElementById("prediction").innerText = `é”å®šè§£é™¤ï¼Œé‡æ–°è¯„ä¼° ${latestIssue+1} æœŸ`;
      } else {
        activeLock.count += 1;
        const pred = activeLock.prediction;
        const record = {
          issue: latestIssue + 1, prediction: pred, actual: "ç­‰å¾…", hit: "",
          time: new Date().toLocaleString(), valid: activeLock.validOnStart, markIndex: i,
          color: activeLock.color, lockedSeq: activeLock.count, oscillation: false, reason: 'momentum'
        };
        predictionRecords.push(record);
        markLines.push({ index: i, color: activeLock.color });
        lastPredictedIssue = latestIssue;
        document.getElementById("prediction").innerText = `é”å®šä¸­ï¼ˆ${activeLock.count}æœŸï¼‰ï¼šé¢„æµ‹ ${record.issue} æœŸ = ${pred}`;
        return;
      }
    }
  }

  if(isOsc){
    const pred = predictDirection(i);
    const valid = isValidZone(i);
    const color = "rgba(120,120,120,0.6)";
    activeLock = { prediction: pred, startIssue: latestIssue + 1, count: 1, predSign: Math.sign(redArr[i] - redArr[i-1]) || 1, active: true, color: color, validOnStart: valid, reason: 'osc' };
    const record = { issue: latestIssue + 1, prediction: pred, actual: "ç­‰å¾…", hit: "", time: new Date().toLocaleString(), valid: valid, markIndex: i, color: color, lockedSeq: 1, oscillation: true, oscRate: Math.round(oscRate*1000)/10, reason: 'osc' };
    predictionRecords.push(record);
    markLines.push({ index: i, color: color });
    lastPredictedIssue = latestIssue;
    document.getElementById("prediction").innerText = `æ£€æµ‹åˆ°æŒ¯è¡ï¼Œè§¦å‘æŒ¯è¡é”å®šï¼šé¢„æµ‹ ${record.issue} æœŸ = ${pred}`;
    return;
  }

  const valid = isValidZone(i);
  const pred = predictDirection(i);
  const predSign = Math.sign(redArr[i] - redArr[i-1]) || 1;
  const color = valid ? (pred === "å¤§" ? "green" : "blue") : "rgba(120,120,120,0.6)";

  if(shouldTriggerLock(i)){
    activeLock = { prediction: pred, startIssue: latestIssue + 1, count: 1, predSign: predSign, active: true, color: color, validOnStart: valid, reason: 'momentum' };
    const record = { issue: latestIssue + 1, prediction: pred, actual: "ç­‰å¾…", hit: "", time: new Date().toLocaleString(), valid: valid, markIndex: i, color: color, lockedSeq: 1, oscillation: false, reason: 'momentum' };
    predictionRecords.push(record);
    markLines.push({ index: i, color: color });
    lastPredictedIssue = latestIssue;
    document.getElementById("prediction").innerText = `è§¦å‘é”å®šï¼ˆå¼ºæ³¢åŠ¨+æ‹‰æ‰¯ï¼‰ï¼šé¢„æµ‹ ${record.issue} æœŸ = ${pred}`;
    return;
  }

  const record = { issue: latestIssue + 1, prediction: pred, actual: "ç­‰å¾…", hit: "", time: new Date().toLocaleString(), valid: valid, markIndex: i, color: color, lockedSeq: 0, oscillation: false };
  predictionRecords.push(record);
  markLines.push({ index: i, color: color });
  lastPredictedIssue = latestIssue;
  document.getElementById("prediction").innerText = valid ? `é¢„æµ‹ ${record.issue} æœŸï¼ˆæœ‰æ•ˆåŒºï¼‰ï¼š${pred}` : `é¢„æµ‹ ${record.issue} æœŸï¼ˆæ— æ•ˆåŒºï¼Œä»è®°å½•ï¼‰ï¼š${pred}`;
}

/* ====== ç»“ç®— ====== */
function settleResults(data){
  predictionRecords.forEach(r=>{
    if(r.actual !== "ç­‰å¾…") return;
    const match = data.find(d=>d.preDrawIssue === r.issue);
    if(!match) return;
    const first = parseInt(match.preDrawCode.split(",")[0]);
    const actual = first<=5 ? "å°" : "å¤§";
    r.actual = actual;
    r.hit = (actual === r.prediction) ? "æ˜¯" : "å¦";
  });
}

/* ====== æ£€æŸ¥çº¢çº¿é˜ˆå€¼ä¸è¿æŒ‚/è¿ä¸­é€šçŸ¥ï¼ˆåŒºé—´æ¥è¿‘è§¦å‘ï¼‰ ====== */
function checkExtraNotifications(data){
  const cfg = loadSettings();
  const highThresh = cfg.high;
  const lowThresh = cfg.low;
  const margin = isNaN(cfg.margin) ? DEFAULT_MARGIN : cfg.margin;
  const latestIssue = data[data.length-1].preDrawIssue;

  // çº¢çº¿å½“å‰å€¼ï¼ˆæœ€åä¸€ä¸ªç‚¹ï¼‰
  const lastIndex = redArr.length - 1;
  let currentHighInRange = false;
  let currentLowInRange = false;
  if(lastIndex >= 0){
    const val = redArr[lastIndex];
    // åŒºé—´ï¼šé«˜é˜ˆ Â± margin
    if(typeof highThresh === "number" && !isNaN(highThresh)){
      if(val >= (highThresh - margin) && val <= (highThresh + margin)) currentHighInRange = true;
    }
    // åŒºé—´ï¼šä½é˜ˆ Â± margin
    if(typeof lowThresh === "number" && !isNaN(lowThresh)){
      if(val >= (lowThresh - margin) && val <= (lowThresh + margin)) currentLowInRange = true;
    }

    // ä»…åœ¨â€œä»å¤–éƒ¨è¿›å…¥åŒºé—´â€æ—¶é€šçŸ¥ä¸€æ¬¡ï¼ˆé¿å…æ¯æœŸé‡å¤ï¼‰
    if(currentHighInRange && !prevHighInRange){
      prevHighInRange = true;
      lastNotifiedHighIssue = latestIssue;
      const rec = { issue: `ALERT-R-HIGH-${latestIssue}`, prediction: `çº¢çº¿è¿›å…¥é«˜é˜ˆåŒºé—´(${highThresh}Â±${margin})`, valid:false, lockedSeq:0, time: new Date().toLocaleString(), oscillation:false };
      notifyTelegramSimple(rec);
      console.log("é€šçŸ¥ï¼šçº¢çº¿è¿›å…¥é«˜é˜ˆåŒºé—´", val, "æœŸ", latestIssue);
    }
    if(!currentHighInRange && prevHighInRange){
      // ç¦»å¼€åŒºé—´åˆ™é‡ç½® prev çŠ¶æ€ï¼Œå…è®¸åç»­å†æ¬¡è¿›å…¥æ—¶è§¦å‘
      prevHighInRange = false;
    }

    if(currentLowInRange && !prevLowInRange){
      prevLowInRange = true;
      lastNotifiedLowIssue = latestIssue;
      const rec = { issue: `ALERT-R-LOW-${latestIssue}`, prediction: `çº¢çº¿è¿›å…¥ä½é˜ˆåŒºé—´(${lowThresh}Â±${margin})`, valid:false, lockedSeq:0, time: new Date().toLocaleString(), oscillation:false };
      notifyTelegramSimple(rec);
      console.log("é€šçŸ¥ï¼šçº¢çº¿è¿›å…¥ä½é˜ˆåŒºé—´", val, "æœŸ", latestIssue);
    }
    if(!currentLowInRange && prevLowInRange){
      prevLowInRange = false;
    }
  }

  // è¿æŒ‚ / è¿ä¸­æ£€æµ‹ï¼ˆåŸºäº predictionRecords ä¸­æœ€æ–°å‘½ä¸­çŠ¶æ€ï¼‰
  let currentMiss = 0, currentHit = 0;
  for(let i = predictionRecords.length - 1; i >= 0; i--){
    const h = predictionRecords[i].hit;
    if(h === "å¦"){ currentMiss++; currentHit = 0; }
    else if(h === "æ˜¯"){ currentHit++; currentMiss = 0; }
    else { break; } // é‡åˆ°ç­‰å¾…åˆ™åœæ­¢
  }

  // è¿æŒ‚é€šçŸ¥ï¼šè§¦å‘æ—¶ä¸º >=3 ä¸”æ¯”ä¸Šæ¬¡é€šçŸ¥çš„æ•°æ›´å¤§ï¼ˆé¿å…é‡å¤ï¼‰
  if(currentMiss >= 3 && currentMiss > lastNotifiedMissStreak){
    lastNotifiedMissStreak = currentMiss;
    const rec = { issue: `ALERT-MISS-${predictionRecords.length}`, prediction: `è¿ç»­æœªä¸­ ${currentMiss} æŠŠ`, valid:false, lockedSeq:0, time: new Date().toLocaleString(), oscillation:false };
    notifyTelegramSimple(rec);
    console.log("é€šçŸ¥ï¼šè¿æŒ‚", currentMiss);
  }
  // è¿ä¸­é€šçŸ¥ï¼šè§¦å‘æ—¶ä¸º >=6 ä¸”æ¯”ä¸Šæ¬¡é€šçŸ¥æ›´å¤§
  if(currentHit >= 6 && currentHit > lastNotifiedHitStreak){
    lastNotifiedHitStreak = currentHit;
    const rec = { issue: `ALERT-HIT-${predictionRecords.length}`, prediction: `è¿ç»­å‘½ä¸­ ${currentHit} æŠŠ`, valid:false, lockedSeq:0, time: new Date().toLocaleString(), oscillation:false };
    notifyTelegramSimple(rec);
    console.log("é€šçŸ¥ï¼šè¿ä¸­", currentHit);
  }
}

/* ======= è½»é‡åŒ–ç»˜å›¾å‡½æ•°ï¼ˆæ›¿æ¢æ—§çš„ drawChartï¼‰ ======= */
function drawChart(){
  const markPlugin = {
    id: 'markPlugin',
    afterDatasetsDraw(chartInstance, args, options) {
      const ctx = chartInstance.ctx;
      if(!Array.isArray(markLines) || markLines.length === 0) return;
      const meta = chartInstance.getDatasetMeta(0); // çº¢çº¿æ•°æ®å…ƒ
      if(!meta || !meta.data) return;
      ctx.save();
      for(const m of markLines){
        const idx = m.index;
        if(idx == null) continue;
        const pt = meta.data[idx];
        if(!pt) continue;
        ctx.beginPath();
        ctx.fillStyle = m.color || 'rgba(120,120,120,0.8)';
        ctx.arc(pt.x, pt.y - 6, 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  };

  if(chart){
    chart.data.labels = labels;
    if(chart.data.datasets && chart.data.datasets.length >= 4){
      chart.data.datasets[0].data = redArr;
      chart.data.datasets[1].data = midArr;
      chart.data.datasets[2].data = upperArr;
      chart.data.datasets[3].data = lowerArr;
    }
    chart.update('none');
    return;
  }

  const datasets = [
    { label:"çº¢çº¿", data:redArr, borderColor:"red", borderWidth:2, pointRadius:0, fill:false, tension:0 },
    { label:"ä¸­è½¨", data:midArr, borderColor:"orange", borderWidth:1, pointRadius:0, fill:false, tension:0 },
    { label:"ä¸Šè½¨", data:upperArr, borderColor:"#999", borderWidth:1, pointRadius:0, fill:false, tension:0 },
    { label:"ä¸‹è½¨", data:lowerArr, borderColor:"#999", borderWidth:1, pointRadius:0, fill:false, tension:0 }
  ];

  chart = new Chart(document.getElementById("chart"), {
    type: 'line',
    data: { labels, datasets },
    options: {
      animation: false,
      responsive: false,
      plugins: { legend: { display: false } },
      elements: { point: { radius: 0 } },
      scales: { x: { display: false }, y: { display: true } },
      interaction: { mode: 'index', intersect: false }
    },
    plugins: [markPlugin]
  });
}

/* ====== é¢æ¿ / ç»Ÿè®¡ / CSV ç­‰ ====== */
function renderPanel(){
  const tbody = document.getElementById("recordBody");
  tbody.innerHTML = "";
  predictionRecords.forEach(r=>{
    const colorStyle = r.hit === "æ˜¯" ? "color:green;font-weight:600" : (r.hit === "å¦" ? "color:red" : "");
    const typeText = r.valid ? "æœ‰æ•ˆ" : "æ— æ•ˆ";
    const lockedText = r.lockedSeq && r.lockedSeq > 0 ? r.lockedSeq : "";
    const oscText = r.oscillation ? `æ˜¯ (${r.oscRate || ''}%)` : "å¦";
    tbody.innerHTML += `<tr>
      <td>${r.issue}</td>
      <td>${typeText}</td>
      <td style="font-weight:600">${r.prediction}</td>
      <td>${r.actual}</td>
      <td style="${colorStyle}">${r.hit}</td>
      <td>${lockedText}</td>
      <td>${oscText}</td>
      <td>${r.time}</td>
    </tr>`;
  });
}

function updateStats(){
  const total = predictionRecords.length;
  const validCount = predictionRecords.filter(r=>r.valid).length;
  const invalidCount = total - validCount;
  const hits = predictionRecords.filter(r=>r.hit === "æ˜¯").length;
  const validHits = predictionRecords.filter(r=>r.valid && r.hit === "æ˜¯").length;
  const invalidHits = predictionRecords.filter(r=>!r.valid && r.hit === "æ˜¯").length;
  const rate = total ? Math.round(hits/total*10000)/100 : 0;
  const validRate = validCount ? Math.round(validHits/validCount*10000)/100 : 0;
  const invalidRate = invalidCount ? Math.round(invalidHits/invalidCount*10000)/100 : 0;

  let maxStreak = 0;
  let curStreakCalc = 0;
  for(let i=0;i<predictionRecords.length;i++){
    const h = predictionRecords[i].hit;
    if(h === "å¦"){ curStreakCalc += 1; if(curStreakCalc > maxStreak) maxStreak = curStreakCalc; }
    else if(h === "æ˜¯"){ curStreakCalc = 0; }
    else { curStreakCalc = 0; }
  }
  let currentStreak = 0;
  for(let i = predictionRecords.length - 1; i >= 0; i--){
    if(predictionRecords[i].hit === "å¦") currentStreak++;
    else break;
  }

  document.getElementById("statTotal").innerText = `æ€»é¢„æµ‹: ${total}`;
  document.getElementById("statValid").innerText = `æœ‰æ•ˆ: ${validCount} (å‘½ä¸­ ${validHits}, ${validRate}%)`;
  document.getElementById("statInvalid").innerText = `æ— æ•ˆ: ${invalidCount} (å‘½ä¸­ ${invalidHits}, ${invalidRate}%)`;
  document.getElementById("statHits").innerText = `å‘½ä¸­: ${hits}`;
  document.getElementById("statRate").innerText = `æ€»ä½“å‘½ä¸­ç‡: ${rate}%`;
  document.getElementById("statCurStreak").innerText = `å½“å‰è¿æŒ‚: ${currentStreak}`;
  document.getElementById("statMaxStreak").innerText = `æœ€å¤§è¿æŒ‚: ${maxStreak}`;

  if(activeLock && activeLock.active){
    document.getElementById("statLock").innerText = `å½“å‰é”å®š: æ˜¯ï¼ˆå·²é” ${activeLock.count} æœŸï¼Œé¢„æµ‹=${activeLock.prediction}, åŸå› =${activeLock.reason}ï¼‰`;
  } else {
    document.getElementById("statLock").innerText = `å½“å‰é”å®š: æ— `;
  }

  const oscRes = detectOscillation();
  document.getElementById("statOsc").innerText = `æŒ¯è¡: ${oscRes.osc ? 'æ˜¯' : 'å¦'} (${Math.round(oscRes.rate*100)}%)`;

  document.getElementById("statDetail").innerText =
    `æç¤ºï¼šé˜ˆå€¼é€šçŸ¥ä½¿ç”¨â€œåŒºé—´æ¥è¿‘â€(é˜ˆå€¼Â±ç¼“å†²)ï¼Œä»…åœ¨ä»åŒºé—´å¤–è¿›å…¥åŒºé—´æ—¶é€šçŸ¥ï¼›æ™®é€šæ¯æœŸé¢„æµ‹ä¸é€šçŸ¥ã€‚`;
}

/* ====== CSV å¯¼å‡º ====== */
function exportPredictionCSV(){
  if(predictionRecords.length === 0) { alert("æš‚æ— é¢„æµ‹è®°å½•"); return; }
  const header = ["issue","type","prediction","actual","hit","lockedSeq","oscillation","time","valid","reason"].join(",");
  const body = predictionRecords.map(r=>{
    return [r.issue, r.valid ? "æœ‰æ•ˆ" : "æ— æ•ˆ", r.prediction, r.actual, r.hit, r.lockedSeq||"", r.oscillation? "æ˜¯":"å¦", r.time, r.valid, r.reason||""].join(",");
  }).join("\n");
  const csv = header + "\n" + body;
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([csv], { type: "text/csv" }));
  a.download = "prediction_records_all.csv";
  a.click();
}

/* ====== å¯åŠ¨ ====== */
fetchData();
setInterval(fetchData, UPDATE_INTERVAL);
</script>
</body>
</html>